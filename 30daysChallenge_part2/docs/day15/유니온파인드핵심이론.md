## 핵심 이론

`Union-Find`는 말 그대로 `Union 연산`과 `Find 연산`으로 구성된 알고리즘이다.  

2개의 연산이 어떤 것인지를 명확히 이해해야 한다.

- union 연산 : 각 노드가 속한 `집합을 하나로 합치는` 연산. 노드 a, b가 a ∈ A, b ∈ B일 때 union(A, B)는 A∪B를 의미한다.

- find 연산 : 노드 a에 대해 `a가 속한 집합의 대표 노드를 반환`하는 연산. 노드 a가 a ∈ A일 때 find(a)는 A 집합의 대표 노드를 반환한다

## 알고리즘 구현 방법

### 1. Union-Find를 표현하는 일반적인 방법 ⇒ `1차원 리스트`

그 리스트에 각 노드의 대표 노드값을 저장한다.  
초기에는 노드가 서로 연결되어 있지 않기 때문에 각 노드의 대표 노드는 자기 자신이다. 

아래 그림
- 왼쪽 : 초기에 노드만 주어지고 아무런 연결이 없는 상태를 나타낸 그림
- 오른쪽 : 왼쪽의 상태를 1차원 리스트로 표현한 그림 

![image](../../image/day15/유니온파인드핵심이론_001.png)


### 2. Union 연산 

`union 연산`은 앞서 `각 노드가 속한 집합을 하나로 합치는` 연산이라고 했다.  
즉, `2개의 노드가 속한 집합을 합친다`는 건 `각 노드가 속한 집합의 대표 노드를 찾아서 연결한다`는 것과 동일하다 

ex. 1, 4와 5, 6을 union 연산으로 연결하고 싶다

이를 위해서는 다음과 같은 과정이 필요하다.

1. 1과 4를 연결(union) & 5와 6을 연결(union)

- 1과 4를 연결(union)  
⇒ 1을 대표 노드로 4를 자식 노드로 union 연산을 하기 때문에  
⇒ `리스트[4] = 1`로 업데이트

- 5와 6을 연결(union)  
⇒ 5를 대표 노드로 6을 자식 노드로 union 연산을 하기 때문에  
⇒ `리스트[6] = 5`로 업데이트

![image](../../image/day15/유니온파인드핵심이론_002.png)

2. (1, 4)와 (5, 6)을 연결(union)

이 동작을 수행하기 위해서 `union(4, 6)` 연산을 실행했다고 하자 

4, 6은 대표노드가 아니다.  
그래서 각 노드의 대표 노드를 찾고 ⇒ 그렇게 찾은 대표노드를 서로 연결한다.

`4의 대표노드는 1` / `6의 대표노드는 5` 이니까 1과 5을 서로 연결한다. 

지금은 `4의 대표노드 1`에 `6의 대표노드 5`를 `연결`했다. 그래서 `리스트[5] = 1`로 업데이트되었다.

![image](../../image/day15/유니온파인드핵심이론_003.png)

### 3. find 연산 

