[링크](https://www.acmicpc.net/problem/17298)

## 1. 문제 분석

크기가 N인 수열 A = A1, A2, ..., An이 있다. 

수열의 각 원소 Ai의 오큰수 NGE(i) = 오른쪽에 있으면서 Ai보다 큰 수 중 가장 왼쪽에 있는 수

ex. A = [3, 5, 2, 7]

- NGE(1) = 5 # 1번째 값보다 오른쪽에 위치 & 1번째 값(=3)보다 큰 수 중 가장 왼쪽에 있는 수
- NGE(2) = 7 # 2번째 값보다 오른쪽에 위치 & 2번째 값(=5)보다 큰 수 중 가장 왼쪽에 있는 수
- NGE(3) = 7 # 3번째 값보다 오른쪽에 위치 & 3번째 값(=2)보다 큰 수 중 가장 왼쪽에 있는 수
- NGE(4) = -1 # 4번째 값보다 오른쪽에 있는 수는 없으므로 -1


수열의 크기가 최대 100만이므로 `단순 반복문`으로 문제를 해결하면 제한 시간을 초과한다. 

`스택 개념`에 아이디어를 추가해 문제를 해결하자.

1. 스택에 새로 들어오는 숫자 > top에 존재하는 숫자 ==> 새로 들어오는 숫자 = 오큰수  
2. 오큰수를 구한 후 수열에서 오큰수가 존재하지 않는 숫자에 -1을 출력해야 한다

## 2. 손으로 풀어보기 

정답 배열의 값을 모두 채운 후 출력하면 문제가 요구하는 답을 구할 수 있다.  
문제 푸는 순서는 다음과 같다.

1. 스택이 채워져 있거나 A[index] > A[top]인 경우  
==> pop한 인덱스를 이용해 정답 수열에 오큰수를 저장  
==> pop은 조건을 만족하는 동안 계속 반복  
==> 이 과정이 끝나면 다음 단계로 넘어간다

2. 현재 인덱스를 스택에 push하고 다음 인덱스로 넘어간다.

3. 과정 1~2를 수열의 길이만큼 반복하고 현재 스택에 남아있는 인덱스에 -1을 저장한다.

![image](../../image/day4/12번_001.png)

1) 스택이 비어있으니까 과정 1없이 `과정 2` 진행. 인덱스 0을 push하고 다음 인덱스로 넘어간다.  
2) A[1] = 5 > A[top] = 3 ==> 스택에서 pop을 수행하고 Result[0]에 오큰수 5를 저장  
    - pop을 한 번 실행했기 때문에 스택이 비었으므로 더 이상 pop을 진행하지 않음
    - 인덱스 1을 push하고 다음 인덱스로 넘어간다.  
3) A[2] = 2 < A[top] = 5 ==> `과정 2`를 진행해서 인덱스 2를 push하고 다음 인덱스로 넘어간다.  

이 과정을 수열의 길이만큼 반복 후 스택에 남아있는 index에 -1을 저장하면 정답 배열을 완성할 수 있다. 

![image](../../image/day4/12번_002.png)

1) 스택이 비어있으니까 인덱스 0을 push하고 다음 인덱스로 넘어간다.  
2) A[1] = 5 < A[top(=0)] = 9 ==> `과정 2`를 진행해서 인덱스 1을 push하고 다음 인덱스로 넘어간다.  
3) A[2] = 4 < A[top(=1)] = 5 ==> `과정 2`를 진행해서 인덱스 2를 push하고 다음 인덱스로 넘어간다.  
4) A[3] = 8 > A[top(=2)] = 4  
==> 스택에서 pop을 수행하고 Result[2]에 8을 저장  
==> 아직 A[3] = 8 > A[top(=1)] = 5 이기 때문에 스택에서 pop을 수행하고 Result[1]에 8을 저장  
==> A[3] = 8 < A[top(=0)] = 9 이기 때문에 pop을 중단 & 인덱스 3을 push한다. 

다음 인덱스가 없으니 3, 0 순서로 pop을 하면서 Result[3], Result[0]에 모두 -1을 저장한다.

## 3. 슈도코드 

``` 
N : 수열 개수 
A : 수열 리스트
ans : 정답 리스트 

A 수열 리스트 채우기 

myStack(스택 선언)

for i in range(N) : 
    while 스택이 비어있지 않고, 현재 수열값이 top에 해당하는 수열보다 클 때까지 : 
        스택에서 pop한 값을 index로 하는 정답 리스트 부분을 수열 리스트의 현재 값(A[i])으로 저장 

while 스택이 빌 때까지 : 
    스택에 있는 index의 정답 리스트에 -1 저장

정답 리스트 출력 
```

`스택의 LIFO`라는 독특한 성질이 종종 시간 복잡도를 줄이거나 특정한 문제의 조건을 손쉽게 해결하는 실마리가 될 때가 있다. 

혹시 스택을 이용하면 쉽게 풀리지 않는지 한 번쯤 고민해보자.

[코드](../../code/day4/12_오큰수구하기.py)