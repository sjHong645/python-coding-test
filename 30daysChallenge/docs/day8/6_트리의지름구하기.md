[링크](https://www.acmicpc.net/problem/1167)

## 1. 문제 분석

- 내 생각

문제에 주어진 대로 그래프를 그려보면 가중치 그래프가 나온다. 

결국 모든 노드를 시작점으로 하는 BFS(또는 DFS)로 접근해야 겠다는 생각이 들었다. 왜냐하면, 특정 시작점이 주어지지 않은 상황에서 가장 거리가 긴 두 노드 사이의 거리를 구해야 하기 때문이다. 

- 모범 답안 

가장 긴 경로를 찾는 방법과 관련된 아이디어가 필요한 문제 

==> 임의의 노드에서 가장 긴 경로로 연결되어 있는 노드는 트리의 지름에 해당하는 두 노드 중 하나다. 

ex. 임의로 선택한 2번째 노드와 가장 긴 경로로 연결되어 있는 노드가 4번째 노드라고 하자. 

==> 트리의 지름은 바꿔말하면 두 노드 사이의 가장 긴 `경로`이다.  
따라서, 앞서 구한 `4번째 노드`는 트리의 지름을 이루는 2개의 노드 중 하나라는 얘기다. 


## 2. 손으로 풀어보기 

![image](../../image/day8/6번_001.png)

![image](../../image/day8/6번_002.png)

1. 2에서 출발하니까 distance[2] == 0
2. 2와 연결된 4에 방문  
    - 2와 4사이의 거리는 4
    - 현재 노드 : 2번째 노드
    - 그래서, distance[4] = distance[2] + 4 = 4   
3. 4는 2, 3, 5와 연결되어 있음
    - 2는 이미 방문했으니 pass
    - 3 방문 => distance[3] = distance[4] + 3 = 7
    - 5 방문 => distance[5] = distance[4] + 6 = 10 

이러한 방식으로 노드를 방문하며 거리 리스트를 업데이트한다. 

![image](../../image/day8/6번_003.png)

![image](../../image/day8/6번_004.png)


## 3. 슈도코드 

``` 
N : 노드 개수
A : 그래프 데이터를 저장할 인접 리스트

for M만큼 반복 : 
    A 인접 리스트에 그래프 데이터 저장

visited 리스트 초기화
distance 리스트 초기화

def BFS(시작점) : 

    큐 자료구조에 시작 노드 삽입
    visited[시작점] = True 

    while 큐가 비어있을 때까지 : 

        node = 큐.pop()

        for node의 이웃노드 : 
            if not visited[이웃노드] : 

                큐.add(이웃노드)
                visited[이웃노드] = True
                distance[이웃노드] = distance[node] + node와 이웃노드의 거리

BFS(임의의 시작점)

distance 리스트에서 가장 큰 값을 가진 노드를 시작점으로 지정 

visited, distance 리스트 초기화
BFS(새로운 시작점) 

distance 리스트에서 가장 큰 수를 정답으로 출력

```

[코드](../../code/day8/6_트리의지름구하기.py)