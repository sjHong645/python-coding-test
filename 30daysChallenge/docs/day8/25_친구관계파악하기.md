[링크](https://www.acmicpc.net/problem/13023)

## 1. 문제 분석

N의 최댓값이 2000이라 알고리즘의 시간복잡도를 고려할 때 좀 자유롭다. 

1번의 DFS의 시간 복잡도는 `O(V+E)`이므로 최대 4000이다. 이를 최대 2000개의 모든 노드에서 실행한다고 하면 4000 * 2000 = 8백만이 나온다. 

따라서, DFS를 사용해도 제한 시간 안에 문제를 풀 수 있겠다.

문제에서 요구하는 A ~ E의 관계는 재귀 함수의 형태와 비슷하다.  
주어진 모든 노드에 DFS를 수행하고 재귀의 깊이가 5 이상이면 1, 아니면 0을 출력한다. 

## 2. 손으로 풀어보기 

![image](../../image/day8/25번_001.png)

![image](../../image/day8/25번_002.png)

## 3. 슈도코드 

- 내가 작성한 슈도 코드 
``` 

node_count, edge_count

graph : 인접 리스트 형식으로 만든 그래프

visited = [False] * node_count

for 주어진 엣지 개수만큼 반복 : 

    그래프에 엣지 내용 추가 

def DFS(n, depth) : 

    if depth == 4 : 
        찾았다

    visited[n] = True 

    for n번 노드의 이웃한 노드 : 

        if visited[이웃 노드] == False : 
            DFS(이웃노드, depth+1)

```

- 모범답안

```
N = 노드 개수; M = 엣지 개수 

A = 그래프 데이터 저장 인접리스트 
visited = 방문 기록 저장 리스트 
arrive = 도착 확인 변수

def DFS(현재 노드, 깊이) : 
    if 깊이 == 5 : 
        arrive = True 
        함수 종료 
    
    visited[현재 노드] = True 

    현재 노드의 연결 노드 중 방문하지 않은 노드로 DFS 실행 

for 엣지 갯수(M) 만큼 반복 : 
    A 인접 리스트에 그래프 데이터 저장 

for 노드 갯수(N) 만큼 반복 : 
    
    각 노드마다 DFS 실행 

if(arrive) == true : 
    print(1)
    return

else : 
    print(0)

```

[코드](../../code/day8/25_친구관계파악하기.py)