[백준 링크](https://www.acmicpc.net/problem/1253)

1. 문제 분석 

- 주어진 숫자의 개수 N <= 2000 
- 각각의 값 <= 10억

바로 생각할 수 있는 방법인 2중 for문을 이용하는 방법은 `좋은 수`를 1개 찾아내는데 O(N^2)이 소요된다.  
따라서, 주어진 숫자의 모든 `좋은 수`를 찾아내려면 O(N^3)이 소요된다. 

이러면 제한 시간안에 문제를 풀 수 없다. 

따라서, 1개의 좋은 수를 찾아내는 알고리즘의 시간 복잡도는 최소 O(nlogn)이어야 한다. 

`정렬`과 `투 포인터 알고리즘`을 사용해서 문제를 해결하자. 
단, 정렬된 데이터에서 자기 자신을 좋은 수 만들기에 포함하면 안 된다. 

`투 포인터 알고리즘`이 적합한 이유는 주어진 데이터 중 `2개의 데이터를 선택`하는 것이 핵심이기 때문이다. 

2. 손으로 풀어보기 

- 숫자들을 입력받아 리스트에 저장 후 정렬 
- 투 포인터 i, j를 배열의 양 끝에 위치 & 조건에 적합한 투 포인터 이동 원칙을 활용해 탐색 수행 
- 2번째 단계를 모든 수에 대해 반복 

![그림](../image/day3/8번_001.jpg)

3. 슈도코드 

``` python 
N = 데이터 개수 
Result = 좋은 수 개수 

A = [숫자 데이터를 저장하는 리스트]

리스트 A 정렬 

for N번 반복 : 
    변수초기화
        - 찾고자 하는 값 find = A[k]
        - 포인터 i, j
    
    while i < j : 
        if A[i] + A[j] == find : 

            # 자기 자신이 i 또는 j번째 값일 수 있음
            if 두 포인터 i 또는 j가 k가 아닐 때 :
                좋은 수 개수 1 증가 & while문 종료 
            
            else :
                포인터 변경 및 while문 계속 수행 

        elif A[i] + A[j] < find : 포인터 i 증가 

        else : 포인터 j 감소 

```

4. [코드 구현](../code/day3/8_좋은수구하기.py)

