[링크](https://www.acmicpc.net/problem/2178)

## 1. 문제 분석

N, M의 최대값은 각각 100이기 때문에 시간 제한은 굳이 생각하지 않아도 된다.

문제에서 요구하는 내용은 `지나야 하는 칸 수`의 최소값을 찾는 것이다.  
==> BFS를 사용해 처음 목적지에 도착했을 때 깊이를 출력하면 문제를 해결할 수 있다.

## 2. 손으로 풀어보기 

예제 2번을 통해 살펴보도록 하자.

1. 2차원 리스트에 데이터를 저장 & (1,1)에서 BFS를 실행
2. 상, 하, 좌, 우 4방향의 인접한 칸을 살펴본다. 
3. 인접한 칸의 숫자가 1 and 아직 방문하지 않았다면 ==> 큐에 삽입 
4. 종료 지점인 (N, M)에서 BFS를 종료 and 깊이 출력 

![image](../../image/day8/27번_001.png)

## 3. 슈도코드 

``` 
dx, dy : 상하좌우를 탐색하기 위한 define 값 정의 변수 

N : row, M : column 

A : 데이터를 저장하는 2차원 행렬
visited : 방문 기록을 저장하는 리스트

for N만큼 반복 : 
    for M만큼 반복 : 
        A 리스트에 데이터 저장

def BFS(n, m) : 

    queue.enqueue(시작노드)

    visited[시작노드] = True 

    while 큐가 비어있을 때까지 : 
        큐에서 노드 데이터 가져오기
        
        for 상하좌우 탐색 : 
            if 유효한 좌표 : 
                if 이동가능한 칸 and 방문하지 않은 노드 : 
                    visited[이웃노드] = True
                    A 리스트에 depth를 현재 노드의 depth + 1로 업데이트
                    큐에 데이터 삽입

BFS(0, 0) 실행
print(A[N-1][M-1])

```

[코드](../../code/day8/27_미로탐색하기.py)
