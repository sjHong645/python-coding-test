[링크](https://www.acmicpc.net/problem/1940)

## 1. 문제 분석

두 숫자의 합. 즉, 크기를 비교하므로 `값을 정렬`하면 문제를 더 쉽게 풀 수 있다. 

N의 최댓값이 15,000이므로 정렬 알고리즘의 시간복잡도가 `O(nlogn) 시간 복잡도` 여도 문제가 없다. 

입력받은 N개의 재료들을 정렬한 다음 양쪽 끝의 위치를 `투 포인터로 지정`해 문제를 풀어보자.

## 2. 손으로 풀어보기 

![image](../../image/day3/7번_001.png)

2. 투 포인터 i, j를 양쪽 끝에 위치시킨 후 문제의 조건에 적합한 포인터 이동 원칙을 활용해서 탐색을 시작한다. 

- 이동 원칙 
1) A[i] + A[j] > M ==> j--   
==> 숫자의 합이 M보다 크니까 큰 쪽의 인덱스를 왼쪽으로 이동

2) A[i] + A[j] < M ==> i++   
==> 숫자의 합이 M보다 작으니까 작은 쪽의 인덱스를 오른쪽으로 이동

3) A[i] + A[j] == M ==> i++; j--; count++;  
==> 숫자의 합이 M과 일치하니까 양쪽의 인덱스를 모두 이동시키고 경우의 수 1 증가 

![image](../../image/day3/7번_002.png)

## 3. 슈도코드 

``` 
N : 재료의 개수 
M : 두 수의 합이 되야 하는 값 

A : 재료를 저장할 리스트 
A 리스트 정렬 

i (시작 인덱스 = 1); j(종료 인덱스 = N-1)
count(정답값 = 0)

while i < j : 
    if 재료 합 > M : 
        j--
    
    elif 재료 합 < M : 
        i++

    else : # 재료 합 == M
        i++; j--; count++

print(count)
```

[코드](../../code/day3/7_주몽의명령.py)