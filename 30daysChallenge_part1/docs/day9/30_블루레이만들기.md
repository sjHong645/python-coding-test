[링크](https://www.acmicpc.net/problem/2343)

## 1. 문제 분석

예제를 통해 문제를 이해해보자

```
9 3 # 9 : 강의의 수, 3 : 블루레이 개수 
1 2 3 4 5 6 7 8 9
```

주어진 입력의 `1 2 3 4 5 6 7 8 9`의 순서를 유지한 채로 3개의 덩어리를 만들어야 한다.  

3개의 덩어리를 만들 수 있는 경우는 여러가지가 있다. 그 중에서 블루레이 크기 중 최소를 구하는 프로그램을 작성해야 한다.

여기서는 `1~5`, `6, 7`, `8, 9`를 넣는 경우가 가능한 블루레이의 크기 중 최소인 경우라고 했다

---

"블루레이의 크기가 모두 같고 녹화 순서가 바뀌지 않아야 한다" 라는 조건이  
이진 탐색 알고리즘을 선택하게 하는 실마리이다. 

블루레이에 처음부터 마지막까지 차례대로 저장하다 보면  
지정한 블루레이 크기로 모든 레슨을 저장할 수 있는지를 판단할 수 있기 때문이다. 

- 모두 저장할 수 있다면 블루레이 크기를 줄이고  
- 저장할 수 없다면 블루레이 크기를 늘린다. 

이 방식으로 블루레이 크기의 최소값을 알 수 있다. 

## 2. 손으로 풀어보기 

1. 시작 인덱스 = 최대 길이의 레슨 / 종료 인덱스 = 모든 레슨 길이의 합 

즉, 시작 인덱스 = 9 / 종료 인덱스 = 45 

블루레이의 개수가 3일 때, 9~45 사이에서 블루레이 크기의 최솟값을 이진 탐색으로 찾아낸다.

![image](../../image/day9/30번_001.png)

1번째 탐색. 중앙값 = (9+45) / 2 = 27 

크기가 27인 블루레이에 강의를 1~9까지 차례대로 저장할 때 총 몇 장의 블루레이가 필요한지 확인한다. ==> `2장이 필요`하다는 걸 알 수 있다.

아직 3장 이내에 모든 레슨을 저장할 수 있기 때문에 `종료 인덱스 = 27-1 = 26`으로 수정한 후 재탐색

2번째 탐색. 중앙값 = (9+26) / 2 = 17 ==> `3장이 필요`하다. 

아직 3장 이내에 모든 레슨을 저장할 수 있기 때문에 `종료 인덱스 = 17-1 = 16`으로 수정한 후 재탐색

3번째 탐색. 중앙값 = (9+16) / 2 = 12 ==> `5장이 필요`하다. 

3장으로 모든 레슨을 저장할 수 없기 때문에 `시작 인덱스 = 12+1 = 13`으로 수정한 후 재탐색

이렇게 탐색을 진행하다가 종료 조건을 만족하면 시작 인덱스는 17이 되고  
이 값이 문제의 조건을 만족하는 블루레이 크기의 최솟값이다. 

## 3. 슈도코드 

``` 
N : 레슨 개수 저장
M : 블루레이 개수 저장 

A : 기타 레슨 데이터 저장 리스트

start, end = 시작, 종료 인덱스 

for A 리스트 탐색 
    시작 인덱스 저장 <= A 리스트 중 최댓값 
    종료 인덱스 저장 <= A 리스트의 총합 

while 시작 인덱스 <= 종료 인덱스 : 

    mid = (시작 인덱스 + 종료 인덱스) / 2
    sum = 레슨 합 
    count = 현재 사용한 블루레이 개수 

    for N번 반복 :

        # 지금까지 더해온 강의 길이 + 현재 강의 길이가 중간값보다 큰 경우
        # 이 상황은 현재 블루레이에 데이터를 저장할 수 없는 상황
        # 그래서 새로운 블루레이를 추가해야 함 
        if sum + 현재 레슨 시간 > 중간 인덱스 : 
            
            count += 1
            sum = 0

        sum += 현재 레슨 시간

    if sum != 0 : 
        마지막 블루레이가 필요하므로 count값 증가 

    # 설정했던 start, middle, end의 상황에서
    # 사용한 블루레이의 개수가 count
    if count > M : 
        시작 인덱스 = 중간 인덱스 + 1 
    else : 
        종료 인덱스 = 중간 인덱스 - 1 

print(시작 인덱스)
```

[코드](../../code/day9/30_블루레이만들기.py)
