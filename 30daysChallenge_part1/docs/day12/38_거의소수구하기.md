[링크](https://www.acmicpc.net/problem/1456)

## 1. 문제 분석

문제에서 정의한 `거의 소수` : (소수)^N 을 만족하는 숫자

---

1. 최대 범위에 해당하는 모든 소수를 구하고  
2. 이 소수들의 N제곱값이 A와 B사이에 존재하는지 판단해서 문제를 해결할 수 있다.

입력에서 주어진 범위의 최댓값 10^14의 제곱근인 10^7까지 소수를 탐색해야 한다.

일단, 에라토스테네스의 체를 이용해 소수를 먼저 구한다.  
그 이후에는 주어진 소수들의 N제곱값이 A~B 범위 안에 존재하는지 판별해 `유효한 거의 소수의 개수를 파악`하면 이 문제를 해결할 수 있다.

## 2. 손으로 풀어보기 

1) 2 ~ 1000만 사이에 존재하는 모든 소수를 구한다.

2)  

![image](../../image/day12/38번_001.png)

`N^k` 계산해서 값을 비교할 때 변수의 표현 범위를 초과하는 경우가 발생한다.  
이러한 오류를 방지하기 위해서 `N^k와 B`를 비교하지 말고 `N과 B / N^(k-1)`를 비교하는 방식으로 식을 적절하게 정리해야 한다

- 추가 설명
    - 비교하고 싶은 내용 : A(최솟값) < N^K < B(최댓값)
    - 그대로 사용하면 저장할 수 있는 숫자의 범위를 넘어 설 수 있으니까
    - A / N^(k-1) < N < B / N^(k-1) 식을 이용해서 비교한다
    - 즉, `A / (N의 제곱수) < N < B / (N의 제곱수)`를 이용해서 문제를 해결한다


## 3. 슈도코드 

``` 
Min : 시작 수 
Max : 종료 수 
A : 소수 리스트 

# 에라토스테네스의 체 부분
for 2 ~ 1000만 : 
    A 리스트 초기화 

for 1000만의 제곱근까지 반복 : 
    소수가 아니면 넘어간다
    for 소수의 배수값을 1000만까지 반복 : 
        현재 숫자가 소수가 아니라는 걸 표시 

for 2 ~ 1000만 : 
    
    if A[i]가 소수일 때 
        # 이제 A[i]의 제곱수가 A와 B 사이에 있는지를 알아내는 부분

        temp <- A[i]값을 temp 변수에 저장 # A[i]를 직접 제곱하면서 알아낼 수는 없으니
                                          # 임의의 변수 temp를 선언

        while A[i] <= Max / temp : # "A[i] = 소수"가 "최댓값 / 소수의 제곱수"보다 작다면 반복문 수행 

            if A[i] >= Min / temp : # "A[i] = 소수"가 "최솟값 / 소수의 제곱수"보다 크다면
                                    # 소수의 제곱수는 바로 "거의 소수" 조건을 만족하는 거니까
                                    # 정답 개수를 1 증가시킴
                정답값 증가 

            temp = temp * A[i]

```

[코드](../../code/day12/38_거의소수구하기.py)
